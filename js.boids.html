<!) {CTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!--<script src="http://grrrwaaa.github.io/gct753/al.min.js"></script>-->
<script src="al.js"></script>
<style>
body {
	background: #eee;
	width: 512px;
	min-height: 100%;
	margin: 50px auto 50px auto;
}
</style>
</head>
<body>
<script>

al.init();


/// put your code here /////////////////////////////////////////////////////////

var max_speed = 0.0025;
var max_force = 0.001;

var agents = [];

function reset() {
	agents = [];
	for (var i = 0; i < 20; i++) {
		var a = {
			pos: new vec2(random(), random()),
			vel: vec2.fromPolar(max_speed, random() * Math.PI * 2),
			acceleration: new vec2(),
		
			dir: random() * Math.PI * 2,
			spd: max_speed * (random() + 0.5),
		
			size: 0.02 + 0.05 * random(),
			mass: 1,
		
			align: new vec2(),
			center: new vec2(),
			canseesomething: false,
		};
		a.viewradius = a.size * 4;
		agents[i] = a;
	}
}
reset();

function move_agent(a) {
	
	// forward Euler integration:
	a.vel.add(a.acceleration);
	a.vel.limit(max_speed);
	a.pos.add(a.vel);
	
	// update the agent's direction:
	a.dir = a.vel.angle();
	a.spd = a.vel.length();
	
	// keep within the 0..1 bounds of the world:
	a.pos.wrap(1);
}

function update_agent(a) {

	// how many agents can I see?
	var neighbors = [];
	var center = new vec2();
	var align = new vec2();
	// for (every agent
	for (i = 0; i < agents.length; i++) {
		var n = agents[i]; 
		// be careful about yourself
		if (n != a) {
			// see if (they are inside the semicircle
			// get relative vector
			var relative = vec2.sub(n.pos, a.pos);
			// wrap in toroidal space:
			relative.add(0.5).wrap(1).add(-0.5);
			relative.rotate(-a.dir);
			var distance = relative.length();
			
			if (distance < a.viewradius && relative.x > 0) {
				
				// add to center calculation:
				center.add(relative);
				// add to velocity average
				align.add(n.vel);
				
				// add to list of neighbors
				neighbors.push(n);
			}
		}
	}
	
	a.canseesomething = neighbors.length > 0;
	if (a.canseesomething) {
		
		// take the average:
		center.div(neighbors.length);
		align.div(neighbors.length);
		align.rotate(-a.dir);
		
		// normalize it:
		center.normalize();
		align.normalize();
			
		var desired_velocity = vec2.add(center, align).mul(a.spd);
		
		var steering = vec2.sub(desired_velocity, new vec2(a.spd, 0));
		var steering_force = steering.limit(max_force);
		
		
		
		// locomotion
		a.acceleration.set(steering_force).div(a.mass);
	
		// go back to global coordinate frame:
		a.acceleration.rotate(a.dir);
	} else {
		// can't see anyone...
		a.acceleration.set(0, 0);
	}
		
	a.center.set(center).mul(0.1);
	a.align.set(align).mul(0.1);
}

// how to render the scene
function draw(ctx) {

	for (var i = 0; i < agents.length; i++) {
		var a = agents[i];
		
		draw2D.push();
			draw2D.translate(a.pos.x, a.pos.y);
			draw2D.rotate(a.dir);
			
			draw2D.color(1, 1, 1, 0.5)
			draw2D.arc(0, 0, -Math.PI/2, Math.PI/2, a.viewradius)
		
			draw2D.color(1, 0, 0)
			//draw2D.line(0, 0, a.align.x, a.align.y)
		
			draw2D.color(1, 1, 0)
			//draw2D.line(0, 0, a.center.x, a.center.y)
			
			draw2D.scale(a.size, a.size);
		
			if (a.canseesomething) {
				draw2D.color(1, 0.5, 1);
			} else {
				draw2D.color(0, 0.5, 1);
			}
			draw2D.circle(0, 0, 1);
			draw2D.color(1, 1, 0);
			draw2D.circle(0.3,  0.3, 1/3);
			draw2D.circle(0.3, -0.3, 1/3);
		
		draw2D.pop();
	}
}

function update() {
	for (var i = 0; i < agents.length; i++) {
		move_agent(agents[i]);
	}
	for (var i = 0; i < agents.length; i++) {
		update_agent(agents[i]);
	}
} 

/// } of user code ///////////////////////////////////////////////////////////

al.start();
</script>
<a href="js.html">Documentation</a>
</body>
</html>