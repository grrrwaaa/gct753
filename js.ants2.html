<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<!--<script src="http://grrrwaaa.github.io/gct753/al.min.js"></script>-->
<script src="al.min.js"></script>
<style>
body {
	background: #eee;
	width: 512px;
	min-height: 100%;
	margin: 50px auto 50px auto;
}
</style>
</head>
<body>
<script>

al.init();

/// put your code here /////////////////////////////////////////////////////////

var dimx = 128, dimy = 64;
var field = new field2D(dimx, dimy);

// computes frequency for a chromatic equal-temperament semitone distance from a center frequency
function chromatic(semitone, centerfreq) {
	return centerfreq * Math.pow(2, semitone/12);
}

// turn it white:
field.set(1);

var ants = [];

// define an ant:
function ant(x, y, spin) {
	this.x = x;
	this.y = y;
	this.direction = 0;
	// which direction the ant should turn when it finds an active cell:
	this.spin = spin;
	
	// add a sinewave osccilator to the ant:
	this.osc = new al.audio.SinOsc().connect();
}

// make some ants!
ants = [
	new ant(32, 20, 1),
	new ant(32, 21, 1),
	new ant(64, 40 + random(3), random(2) ? 1 : -1),	
	new ant(64, 40 + random(3), random(2) ? 1 : -1),	
	new ant(94 + random(3), 20, random(2) ? 1 : -1),
	new ant(94 + random(3), 20, random(2) ? 1 : -1),	
];

// how to render the scene
function draw(ctx)	{
	// draw the field (by default it fills the canvas):
	field.draw();
	
	for (var j = 0; j < ants.length; j++) {
		var ant = ants[j];
		if (ant.spin == 1) {
			ctx.fillStyle = "red";
		} else {
			ctx.fillStyle = "green";
		}
		ctx.fillRect(ant.x*4,ant.y*4,4,4);
	}
}

// how often update() will be called per second:
al.fps = 20;

function update(dt) {
	for (var j = 0; j < ants.length; j++) {
		var ant = ants[j];

		// move the ant.
		if (ant.direction == 0) {
			// North
			ant.y = (ant.y + 1) % field.height;
		} else if (ant.direction == 1) {
			// West
			ant.x = (ant.x - 1) % field.width;
		} else if (ant.direction == 2) {
			// South
			ant.y = (ant.y - 1) % field.height;
		} else {
			// East
			ant.x = (ant.x + 1) % field.width;
		}
	
		// apply the rule.
		var state = field.get(ant.x, ant.y);
		if (state == 1) {
			// change the cell state:
			field.set(0, ant.x, ant.y);
			// turn in the preferred direction:
			ant.direction = wrap(ant.direction + ant.spin, 4);
		} else {
			// change the cell state:
			field.set(1, ant.x, ant.y);
			// turn in the opposite direction:
			ant.direction = wrap(ant.direction - ant.spin, 4);
		}
	
		// update the ant oscillator frequency according to 
		// vertical position and direction:
		ant.osc.freq = chromatic(dimy - ant.y, 40) 
					 * (1 + ant.direction);
		// update the ant spatial position:
		ant.osc.pan = ant.x / dimx;
		
		// ant.osc.amp
	}
}

function reset() {
	field.set(1);
}

/// end of user code ///////////////////////////////////////////////////////////

al.start();
</script>
<a href="js.ants.html">See also ants1</a>
</body>
</html>